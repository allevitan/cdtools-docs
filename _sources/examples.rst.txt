Examples
========

Included with the repository are a number of example scripts that demonstrate how various aspects of CDTools work. It is recommended to read through at least a few of them before continuing to the tutorial, to get a feel for how the ptychography scripts work.


Inspect Dataset
---------------

The most important thing to be able to do is look at the raw data and confirm that it looks like you expect, hasn't been corrupted, etc. This script demonstrates how to load and look at your data, if it's stored as a compliant .cxi file.

.. literalinclude:: ../../examples/inspect_dataset.py

First, data is read into a dataset object. The dataset object knows how to generate a set of plots describing the basic information (diffraction patterns and nanomaps), which can be generated by running :code:`dataset.inspect`.

		    
Simple Ptycho
-------------

This script runs a ptychography reconstruction using the SimplePtycho model. This model implements a straightforward transmission ptychography geometry, with no position refinement, incoherent modes, or other doodads (only a background model). 

.. literalinclude:: ../../examples/simple_ptycho.py

Because this script only runs ten iterations, the quality of the reconstruction is relatively poor - however, on this particular dataset, running 75 or so iterations will lead to a surprisingly good reconstruction. On other datasets, however, it will often fail to converge, even in some cases where there is little error in the data.

When reading this script, note the basic workflow. After the data is loaded, a model is created to match the geometry stored in the dataset, with a default initialization for all the parameters. Next, a reconstruction is run (and the progress reported out). Finally, the finished reconstruction is plotted.


Gold Balls Ptycho
-----------------

This script uses the FancyPtycho model to perform a reconstruction from the classic `gold balls <http://www.cxidb.org/id-65.html>`_ dataset. The FancyPtycho model is the workhorse model for 2D Ptychographic reconstructions, and has the option to enable correction for a variety of potential sources of error.

.. literalinclude:: ../../examples/gold_ball_ptycho.py

A number of things are changed about this script. The first difference is the section where we transfer the data and the model to the GPU. This is an important step if we would like to get a reconstruction anytime soon!

Next, note that we can liveplot the results by calling :code:`model.inspect` within the reconstruction loop. In fact, we could put any code we wanted here to look at the state of the model, and it would be executed after each epoch.

Finally, note that we take the time to save the results of this reconstruction. This is handled by pickling the dictionary produced by :code:`model.save_results`, which contains all the parameters which were reconstructed by the model.

There are a number of things going on behind the scenes as well, just because we decided to use the FancyPtycho model. This reconstruction, in addition to using two incoherently mixing modes, is also performing position annealing and reconstructing any instabilities in the probe flux that might have occured.


MIT BNL Logo
------------

Next, we look at an example showing a more involved reconstruction from a dataset that has some serious errors in it. This is a dataset we collected at the CSX beamline of NSLS-II in 2016 from a target that said "MIT BNL" on it, using a defocused zone plate.

.. literalinclude:: ../../examples/MIT_BNL_logo.py

The first new thing that pops out at us is the choice to remove part of the diffraction patterns stored in the dataset. In this case, that data is noisy, and in any case, it's masked off with the mask stored in the .cxi file. We can simply edit all the patterns like we would any other pytorch or numpy array, taking care to crop the mask as well to match.

The next thing we note is that a few more options are being taken advantage of during the model construction. First of all, we introduce the :code:`translation_scale` option, which sets the aggressiveness of the position reconstruction. A small number like 1 (the default) is often too mild when there are large errors, whereas numbers above 10 are often too agressive to lead to convergence.

In this case, the :code:`propagation_distance` option tells us how far to propagate the naive initial guess of the probe. This data was taken from a very defocused zone plate, which is a classic difficult-to-reconstruct probe. The standard probe initialization, however, is generally quite good at generating a good guess of the focal point of any zone-plate-like optics. This option lets us start with a guess of that probe, which has already been propagated from it's focal point by a known distance.

Next, note that we can start to play a bit with the reconstruction procedure in response to the kinds of error that exist in the data. In this case, we actually perform three rounds of reconstruction, in serial, with different parameters! First, we we turn off the position reconstruction, and run the reconstruction with an explicitly chosen batch size which was found to work well with this dataset. Next, we turn position reconstruction back on, and continue the reconstruction. Finally, we improve the reconstruction quality by running ten iterations at a smaller learning rate (the default is set to a sensible 0.005).


Specular Ptycho
---------------

This file demonstrates a reconstruction from an experiment in the specular reflection geometry.

.. literalinclude:: ../../examples/specular_ptycho.py

While the reconstruction itself is simple this time, a few new parameters have been set in the model definition. First, the :code:`randomize_ang` parameter was set. This seeds the object with phase noise spanning a given angular range, rather than a constant. Second, the :code:`scattering_mode` parameter is set. When set, it will override any information in the .cxi file about the sample orientation, and define the orientation based on the detector geometry.

In this case, the 'reflection' geometry knows to set the sample normal parallel to the scattering vector defined by an outgoing ray which intersects the detector at a perpendicular, and an incoming ray along the positive z-direction (as defined in the cxi specification). The other options, 'transmision', assumes that the surface normal of your sample is parallel to the incoming light ray. If this is left unset, it will use any information stored in the .cxi file, and will default to a transmission geometry if no data exists.


Ensemble Reconstruction
-----------------------

One important check when working with ptychography is performing multiple independently seeded reconstructions from the same data, to understand to what extent they converge to the same solution. This script demonstrates how to run an ensemble of reconstructions

.. literalinclude:: ../../examples/ensemble_reconstruction.py

Note that essentially all that's different here is that the reconstructions are performed within a loop, with each reconstruction added to a list. Importantly, the :code:`randomize_ang` parameter is set, so that the reconstructions are seeded with a different pattern of noise.



Ensemble Analysis
-----------------

This file inspects the results from the ensemble reconstruction

.. literalinclude:: ../../examples/ensemble_analysis.py

After loading the results and manipulating them a bit using regular python, two analysis functions from CDTools are used to glean information from the ensemble.

First is :code:`analysis.synthesize_reconstructions`. This function takes a stack of reconstructed probes and objects, corrects each reconstruction to account for the various ambiguities (phase ramps, translation offsets, etc.), and sums them into a single synthesized probe and object. Once the reconstructions are synthesized, this final synthesized probe and object can be plotted

Second is :code:`analysis.calc_consistency_prtf`. This function compares the power into various spatial frequencies between a stack of individual reconstructions and a synthesized reconstruction, in analogy with the phase retrieval transfer function. It then outputs a curve analogous to the PRTF, that shows at what spatial frequencies the reconstructions have converged consistently. This result is then plotted as well.



