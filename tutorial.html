<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial &mdash; CDTools 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=938c9ccc"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="General Reference" href="general.html" />
    <link rel="prev" title="Examples" href="examples.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            CDTools
          </a>
              <div class="version">
                0.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction to CDTools</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reconstruction-scripts">Reconstruction Scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#datasets">Datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-idea">Basic Idea</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-the-skeleton">Writing the Skeleton</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataset-interface">Dataset Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-and-saving">Loading and Saving</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inspecting">Inspecting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#models">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Basic Idea</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Writing the Skeleton</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-from-python">Initialization from Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-from-dataset">Initialization from Dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-forward-model">The Forward Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-management">Device Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting">Plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving">Saving</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="general.html">General Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="indices_tables.html">Indices and tables</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CDTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading"></a></h1>
<p>WARNING: THE FOLLOWING TUTORIAL IS OUT OF DATE! It has some helpful information, but it is not trustworthy. Please rely on the examples, which are current as of February 2024.</p>
<p>This tutorial builds on the examples, leading to a more complete understanding of how to use CDTools and - importantly - how to extend it. First, we will cover the details of writing a useful reconstruction script for a particular experiment. Next, we will discuss how to implement a new dataset type for different kinds of coherent diffraction. Finally, we will go over how to make new models to cover specific types of ptychography which aren’t described by any of the built-in models.</p>
<section id="reconstruction-scripts">
<h2>Reconstruction Scripts<a class="headerlink" href="#reconstruction-scripts" title="Link to this heading"></a></h2>
<p>In this section, we will write a script to run a reconstruction on a dataset collected from our benchtop optical ptychography playground. This mirrors very closely the reconstruction examples, however I encourage everyone to follow along, writing this script out line-by-line, to help you learn more permanently the process of writing a custom reconstruction script.</p>
<p>Our first step will be creating the file and filling out the boilerplate: All the imports we’ll need.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cdtools</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">io</span>
</pre></div>
</div>
<p>You can always import more libraries, like numpy, or pytorch, or pandas, or what have you, as needed. Next, we load the dataset and give it a look-over</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;example_data/lab_ptycho_data.cxi&#39;</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">cdtools</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">Ptycho2DDataset</span><span class="o">.</span><span class="n">from_cxi</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="n">dataset</span><span class="o">.</span><span class="n">inspect</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Now, run this script! You should see a window pop up, showing a nanomap of the integrated intensities at each scan point on one side, and an individual diffraction pattern on the other. You can then click around to make sure that everything is in order.</p>
<p>Now that we know we have the data loaded and it looks good, we can go ahead and comment out the dataset inspecting code, and move on to creating a model. It’s usually a good idea to start by loading a standard <code class="code docutils literal notranslate"><span class="pre">FancyPtycho</span></code> model without any special changes, sending it to the GPU.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">cdtools</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">FancyPtycho</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">dataset</span><span class="o">.</span><span class="n">get_as</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We then try a basic Adam reconstruction with this model, with no changes to the defaults, to see how it works.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">Adam_optimize</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">report</span><span class="p">())</span>

<span class="n">model</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It is worth noting here exactly how this code is working. The reconstruction methods are actually returning generators. Generators in pythons are objects that work like lists, or tuples, but have to be read out one item at a time, from left to right. The catch is that, instead of just reading out objects from a list, they can run arbitrary code each time they are asked for the “next” item.</p>
<p>In CDTools, every reconstruction method will return a generator. Whenever the generator is asked for the next item, it runs a single epoch of the reconstructionalgorithm, and then returns the average loss over that epoch as that next item. This allows the execution of the reconstruction algorithm to pause once every epoch, allowing some time for the user to run a small snippet of code to inspect how the reconstruction is coming along.</p>
<p>From the end user perspective, all this means is: follow the format above, or more generally put the <code class="code docutils literal notranslate"><span class="pre">model.Adam_optimize(n,</span> <span class="pre">dataset)</span></code> call anywhere that you would feel comfortable putting a call to <code class="code docutils literal notranslate"><span class="pre">range(n)</span></code> - list comprehensions, for loops, etc. In this case, we have called a function to plot out the current state of the reconstruction, and a function to print out the current loss and iteration time.</p>
<p>Once we run this, we can take a look at the result. What we see is pretty good, but we can see that there are some issues with the reconstruction near the edge, and the probe itself seems to be larger than the “stage” on which we’re reconstructing it. So, we can make two tweaks to this code in response. First, we increase the oversampling ratio, which doubles the size of the stage (this often can cause other issues as well, but generally works well in situations like this where the probe is honestly too large.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">cdtools</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">FancyPtycho</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>And secondly, we note that there don’t seem to be any errors with the positioning. So we can just not reconstruct the probe positions, knowing that the initial guesses are already accurate enough. We can do this by writing the following line, just before we run the reconstruction for loop.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">translation_offsets</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>What is going on here is that, when running the optimization algorithm, pytorch will automatically calculate gradients for and then optimize over a number of parameters defined in the model - this includes parameters like <code class="code docutils literal notranslate"><span class="pre">model.probe</span></code>, <code class="code docutils literal notranslate"><span class="pre">model.obj</span></code>, <code class="code docutils literal notranslate"><span class="pre">model.background</span></code>, etc. We can tell pytorch to stop calculating gradients for (and stop updating) any of these parameters by setting their <code class="code docutils literal notranslate"><span class="pre">requires_grad</span></code> property to <code class="code docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>After running this reconstruction, we can see that we’re getting a little improvement (and a larger field of view) by using oversampling, but out in the corners we’re nucleating extra probes! We can fix this by adding a probe support - that is, declating that the probe has to be defined only within a certain box. This can be done most easily with an argument to the model constructor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">cdtools</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">FancyPtycho</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                <span class="n">probe_support_radius</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
</pre></div>
</div>
<p>It also seems like we need a few more iterations to finish converging, so we up the iteration count to 100.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">Adam_optimize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)):</span>
</pre></div>
</div>
<p>Now we expect to get a nice reconstruction, so we can save the data. You can save the data in any form you like, once the relevant information is extracted from the model and put into a dictionary. The standard method for saving out this information is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s1">&#39;example_reconstructions/lab_ptycho.pickle&#39;</span><span class="p">,</span>
           <span class="n">model</span><span class="o">.</span><span class="n">save_results</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
</pre></div>
</div>
<p>This is usually placed before the call to <code class="code docutils literal notranslate"><span class="pre">plt.show()</span></code>, to make sure that if the user manually exits the program once all the plot windows are opened, the data will still have been saved.</p>
<p>Now, your file should match the example file in examples/lab_ptycho_data.py.</p>
</section>
<section id="datasets">
<h2>Datasets<a class="headerlink" href="#datasets" title="Link to this heading"></a></h2>
<p>In this section, we will write a bare-bones dataset class for 2D ptychography data to demonstrate the process of writing a new dataset class. At the end of the tutorial, we will have written the file examples/basic_ptycho_dataset.py, which can be consulted for reference.</p>
<section id="basic-idea">
<h3>Basic Idea<a class="headerlink" href="#basic-idea" title="Link to this heading"></a></h3>
<p>At it’s core, a dataset object for CDTools is just an object that implements the dataset interface from pytorch. For this reason, the base class (<code class="code docutils literal notranslate"><span class="pre">CDataset</span></code>) from which all the datasets are defined is itself a subclass of <code class="code docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code>. In addition, CDataset implements an extra layer that allows for a separation between the device (CPU or GPU) that the data is stored on and the device that it returns data on. This allows for GPU-based reconstructions on datasets that are too large to fit into the GPU in their entirety.</p>
<p>The pytorch Dataset interface is very simple. A dataset simply has to define two functions, <code class="code docutils literal notranslate"><span class="pre">__len__()</span></code> and <code class="code docutils literal notranslate"><span class="pre">__getitem__()</span></code>. Thus, we can always access the data in a Dataset <code class="code docutils literal notranslate"><span class="pre">mydata</span></code> using the syntax <code class="code docutils literal notranslate"><span class="pre">mydata[index]</span></code> or <code class="code docutils literal notranslate"><span class="pre">mydata[slice]</span></code>. Overriding these functions will be the first task in defining a new dataset.</p>
<p>In CDTools datasets, the layer that allows for separation between the device that data is stored on and the device that data is loaded onto is implemented in the <code class="code docutils literal notranslate"><span class="pre">__getitem__()</span></code> function. Instead of overriding this function directly, one should override the <code class="code docutils literal notranslate"><span class="pre">_load()</span></code> function, which is used internally by <code class="code docutils literal notranslate"><span class="pre">__getitem__()</span></code>.</p>
<p>In addition to acting as a pytorch Dataset, CDTools Datasets also work as interfaces to .cxi files. Therefore, when writing a new dataset, it is important to also override the functions <code class="code docutils literal notranslate"><span class="pre">to_cxi()</span></code> and <code class="code docutils literal notranslate"><span class="pre">from_cxi()</span></code> which handle writing to and reading from cxi files, respectively.</p>
<p>The final piece of the puzzle is the <code class="code docutils literal notranslate"><span class="pre">inspect()</span></code> method. This is not required to be defined for all datasets, however it is extremely valuable to offer a simple way of exploring a dataset visually. Therefore it is highly recommended to implement this function, which should load a plot or interactive plot that allows a user to visualize the data that they have loaded.</p>
</section>
<section id="writing-the-skeleton">
<h3>Writing the Skeleton<a class="headerlink" href="#writing-the-skeleton" title="Link to this heading"></a></h3>
<p>We can start with the basic skeleton for this file. In addition to our standard imports, we also import the base CDataset class and the data tools. We then define an <code class="code docutils literal notranslate"><span class="pre">__all__</span></code> list as good practice, and set up the inheritance of our class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span> <span class="k">as</span> <span class="nn">t</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">cdtools.datasets</span> <span class="kn">import</span> <span class="n">CDataset</span>
<span class="kn">from</span> <span class="nn">cdtools.tools</span> <span class="kn">import</span> <span class="n">data</span> <span class="k">as</span> <span class="n">cdtdata</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BasicPtychoDataset&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">BasicPtychoDataset</span><span class="p">(</span><span class="n">CDataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The standard dataset for a 2D ptychography scan&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Link to this heading"></a></h3>
<p>The next thing to implement is the initialization code. Here we can leverage some of the work already done in the base CDataset class. There are a number of kinds of metadata that can be stored in a .cxi file that aren’t related to the kind of experiment you’re performing - sample ID, start and end times, and so on. The CDataset’s initialization routine handles loading and storing these various kinds of metadata, so we can start the definition of our initialization routine by leveraging this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">BasicPtychoDataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, there is also some data that are unique to this kind of dataset. In this case, those data are the probe translations and the measured diffraction patterns. Therefore, we extend this definition to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translations</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the dataset from python objects&quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">(</span><span class="n">BasicPtychoDataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">translations</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">translations</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="dataset-interface">
<h3>Dataset Interface<a class="headerlink" href="#dataset-interface" title="Link to this heading"></a></h3>
<p>The next set of functions to write are those that plug into the dataset interface. We want <code class="code docutils literal notranslate"><span class="pre">len(dataset)</span></code> to return the number of diffraction patterns, which is straightforward to implement.</p>
<p>For the <code class="code docutils literal notranslate"><span class="pre">_load()</span></code> implementation, we need to consider what format the data should be returned in. The standard for all CDTools datasets is to return a tuple of (inputs, output). The inputs should always be defined as a tuple of inputs, even if there is only one input for this kind of data. As we will see later in the section on constructing models, this makes it possible to write the automatic differentiation code in a way that is applicable to every model.</p>
<p>In this case, our “inputs” will be a tuple of (pattern index, probe translation). This is not the only reasonable choice - it would also be possible, for example to define the input as just a pattern index (and store the probe translations in the model). For simple ptychography models with no error correction, it’s also possible to just take a probe translation as an input with no index. Requiring both is the compromise that’s been implemented in the default ptychography models defined with CDTools, and therefore we will follow that format here.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translations</span><span class="p">[</span><span class="n">index</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>Remember that it’s not needed to worry about what device or datatype the data is stored as here, as the relevant conversions will be performed by the <code class="code docutils literal notranslate"><span class="pre">__getitem()</span></code> method defined in the superclass. However, we do generally implement a method, <code class="code docutils literal notranslate"><span class="pre">to()</span></code>, that moves the data back and forth between devices and datatypes. This lets a user speed up data loading onto the GPU by preloading the data, for example - provided there is enough space.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sends the relevant data to the given device and dtype&quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">BasicPtychoDataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">translations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translations</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we can see that we first make sure to call the superclass function to handle sending any information (such as a pixel mask, or detector background) that would have been defined in CDataset to the relevant device. Then we handle the new objects that are defined specifically for this kind of dataset.</p>
</section>
<section id="loading-and-saving">
<h3>Loading and Saving<a class="headerlink" href="#loading-and-saving" title="Link to this heading"></a></h3>
<p>Now we turn to writing the tools to load and save data. First, to load the data, we override <code class="code docutils literal notranslate"><span class="pre">from_cxi()</span></code>, which is a factory method. In this case, we start by using the superclass to load the metadata. Then we explicitly load in and add the data that’s specific to this dataset class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_cxi</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cxi_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a new CDataset from a .cxi file directly&quot;&quot;&quot;</span>

    <span class="c1"># Generate a base dataset</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">CDataset</span><span class="o">.</span><span class="n">from_cxi</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">)</span>
    <span class="c1"># Mutate the class to this subclass (BasicPtychoDataset)</span>
    <span class="n">dataset</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="c1"># Load the data that is only relevant for this class</span>
    <span class="n">patterns</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">cdtdata</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">)</span>
    <span class="n">translations</span> <span class="o">=</span> <span class="n">cdtdata</span><span class="o">.</span><span class="n">get_ptycho_translations</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">)</span>

    <span class="c1"># And now re-add it</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">translations</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">translations</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">patterns</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">dataset</span>
</pre></div>
</div>
<p>Now to save the data, we override <code class="code docutils literal notranslate"><span class="pre">to_cxi()</span></code>, in a fairly self-explanatory way.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_cxi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cxi_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Saves out a BasicPtychoDataset as a .cxi file&quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">(</span><span class="n">BasicPtychoDataset</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_cxi</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">)</span>
    <span class="n">cdtdata</span><span class="o">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">cdtdata</span><span class="o">.</span><span class="n">add_ptycho_translations</span><span class="p">(</span><span class="n">cxi_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translations</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that these functions should be defined to work on h5py file objects representing the .cxi files (.cxi files are just .h5 files with a special formatting).</p>
</section>
<section id="inspecting">
<h3>Inspecting<a class="headerlink" href="#inspecting" title="Link to this heading"></a></h3>
<p>The final piece of the puzzle is writing a function to look at your data! This is an important thing to work on for a dataset class that you intend to use regularly, as being able to easily peruse your raw data has incalculable value. Here, we satisfy ourselves with just plotting a random diffraction pattern.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plots a random diffraction pattern&quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patterns</span><span class="p">[</span><span class="n">index</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
</pre></div>
</div>
</section>
<section id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h3>
<p>This is a bare-bones class, set up to demonstrate the minimum neccessary to develop a new type of dataset class. As a result, it doesn’t implement a number of things that are useful or valuable in practice (and which the default Ptycho2DDataset does implement). That includes a useful data inspector, the ability to load datasets directly from filenames, and default tweaks to how metadata such as backgrounds and masks are loaded.</p>
</section>
</section>
<section id="models">
<h2>Models<a class="headerlink" href="#models" title="Link to this heading"></a></h2>
<p>In this section, we will write a basic model for 2D ptychography reconstructions. At the end of this tutorial, we will have written the class defined in examples/simple_ptycho_model.py</p>
<section id="id1">
<h3>Basic Idea<a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Just like CDTools Datasets subclass pytorch Datasets, CDTools models subclass pytorch modules (yes, I know they are different words - we use the word “model” in CDTools to conform to usage in the world of ptychography/CDI). The major difference is that the base CDTools models also contains a few standard methods to run automatic differentiation reconstructions on itself. This isn’t necessarily the cleanest or most portable approach, but we’ve found that it feels very natural from the perspective of an end user interacting with the toolbox only through some basic reconstruction scripts.</p>
<p>The models themselves have a <code class="code docutils literal notranslate"><span class="pre">model.forward()</span></code> function which contains the real meat. In any CDTools model, this forward function takes in a set of parameters describing the specific diffraction pattern to simulate, and outputs a simulated diffraction pattern. The inputs could be as simple as a diffraction pattern index, or could explicitly include other information like the probe position.</p>
<p>In practice, the forward model is defined in the top level <code class="code docutils literal notranslate"><span class="pre">CDIModel</span></code> class from which all other models are derived. The definition is quite simple:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_propagator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interaction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
</pre></div>
</div>
<p>So we can see that to fully implement this forward model, we have to define the three functions <code class="code docutils literal notranslate"><span class="pre">model.interaction()</span></code>, <code class="code docutils literal notranslate"><span class="pre">model.forward_propagator()</span></code>, and <code class="code docutils literal notranslate"><span class="pre">model.measurement()</span></code>, which simulate conceptual stages in the diffraction process.</p>
<p>Beyond the basic model definition, a few other tools need to be defined. The model has to be able to create itself from a dataset, has to have a loss function defined for use with automtic differentiation, has to know how to plot out it’s progress, and has to be able to save out the results of a reconstruction. The details of how to implement all of this in a model are shown below.</p>
</section>
<section id="id2">
<h3>Writing the Skeleton<a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>Once again, we start with the basic skeleton</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span> <span class="k">as</span> <span class="nn">t</span>
<span class="kn">from</span> <span class="nn">cdtools.models</span> <span class="kn">import</span> <span class="n">CDIModel</span>
<span class="kn">from</span> <span class="nn">cdtools</span> <span class="kn">import</span> <span class="n">tools</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SimplePtycho&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">SimplePtycho</span><span class="p">(</span><span class="n">CDIModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple ptychography model for exploring ideas and extensions&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Note that we imported the full tools package, as we will find ourselves using many low-level functions defined there to implement the model.</p>
</section>
<section id="initialization-from-python">
<h3>Initialization from Python<a class="headerlink" href="#initialization-from-python" title="Link to this heading"></a></h3>
<p>Two initialization functions need to be written. First, we write the <code class="code docutils literal notranslate"><span class="pre">__init__()</span></code> function, which initializes the model from a collection of python objects describing the system. We then write an initializer that creates a model using a dataset to define the various parameters.</p>
<p>It’s important to note that there’s not requirement for what the arguments to the initialization function of any particular model should be, only that they contain enough information to run the simulations! It should be chosen in a model-by-model way to allow for the most transparent code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe_basis</span><span class="p">,</span> <span class="n">probe_guess</span><span class="p">,</span> <span class="n">obj_guess</span><span class="p">,</span>
             <span class="n">min_translation</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>

    <span class="c1"># We have to initialize the Module</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">SimplePtycho</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="c1"># We first save the relevant information</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">min_translation</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">min_translation</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">probe_basis</span><span class="p">)</span>

    <span class="c1"># We rescale the probe so it learns at the same rate as the object</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">probe_guess</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">probe_guess</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
                                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">obj_guess</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">complex64</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, we chose to define the model based on a basis matrix describing the probe array, an initial guess at the probe, and an initial object. In addition, an optional offset for the translations is included.</p>
<p>The first part of this initialization is quite straightforward - we create some tensors for the minimum translation and the probe basis. But then, the next two pieces of information that we save are defined as <code class="code docutils literal notranslate"><span class="pre">t.nn.Parameter</span></code> objects, not Tensors! Parameters are different from Tensors in two ways.</p>
<p>The first way that they are different is that, by default, they have the <code class="code docutils literal notranslate"><span class="pre">requires_grad</span></code> flag set to <code class="code docutils literal notranslate"><span class="pre">True</span></code>, which means that the information needed for gradient calculations will be stored on every Tensor that results from a calculation including a Parameter. The second difference is that, when a Parameter is added to a Module, the Module adds that parameter to a list, which can be accessed by calling <code class="code docutils literal notranslate"><span class="pre">module.parameters()</span></code>.</p>
<p>The key here is that the model itself is subclassing a pytorch Module. So, every parameter that we will attempt to reconstruct, we add to the CDTools model as a Parameter. This way, the model automatically knows which variables to update with gradient descent, and which to keep as they are. Here, we only need to reconstruct the probe and object.</p>
<p>One final note is that we actually store a scaled version of the probe. This is a hack. It is simply because the Adam optimization method, which is the most commonly used, uses learning rates that scale with the amplitude of the parameter, rather than with the amplitude of it’s gradients. Unti pytorch implements separate parameter-group learning rates in Adam, rescaling all the parameters to have a typical amplitude near 1 is the best way to get well-behaved reconstructions.</p>
</section>
<section id="initialization-from-dataset">
<h3>Initialization from Dataset<a class="headerlink" href="#initialization-from-dataset" title="Link to this heading"></a></h3>
<p>To initialize the object from a dataset, we need to start by extracting the relevant information from the dataset. Then we can simply call the constructor we defined earlier.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="c1"># First, load the information from the dataset</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">wavelength</span>
    <span class="n">det_basis</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">detector_geometry</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span>
    <span class="n">det_shape</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">detector_geometry</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span>
    <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">translations</span><span class="p">),</span> <span class="n">patterns</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:]</span>

    <span class="c1"># Then, generate the probe geometry</span>
    <span class="n">ewg</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">exit_wave_geometry</span>
    <span class="n">probe_basis</span><span class="p">,</span> <span class="n">probe_shape</span><span class="p">,</span> <span class="n">det_slice</span> <span class="o">=</span>  <span class="n">ewg</span><span class="p">(</span><span class="n">det_basis</span><span class="p">,</span>
                                               <span class="n">det_shape</span><span class="p">,</span>
                                               <span class="n">wavelength</span><span class="p">,</span>
                                               <span class="n">distance</span><span class="p">)</span>

    <span class="c1"># Next generate the object geometry</span>
    <span class="n">pix_translations</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">interactions</span><span class="o">.</span><span class="n">translations_to_pixel</span><span class="p">(</span>
        <span class="n">probe_basis</span><span class="p">,</span> <span class="n">translations</span><span class="p">)</span>
    <span class="n">obj_size</span><span class="p">,</span> <span class="n">min_translation</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">calc_object_setup</span><span class="p">(</span>
        <span class="n">probe_shape</span><span class="p">,</span> <span class="n">pix_translations</span><span class="p">)</span>

    <span class="c1"># Finally, initialize the probe and  object using this information</span>
    <span class="n">probe</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">SHARP_style_probe</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span>
                                                 <span class="n">probe_shape</span><span class="p">,</span>
                                                 <span class="n">det_slice</span><span class="p">)</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">obj_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">probe_basis</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">min_translation</span><span class="o">=</span><span class="n">min_translation</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we start by pulling the basic geometric information from the dataset. Then, we use a number of the basic tools to do calculations such as finding the probe basis from the detector geometry, or calculating how big our object array should be.</p>
<p>Once we have the basic setup ready, we then use one of the initialization functions - in this case, <code class="code docutils literal notranslate"><span class="pre">tools.initializers.SHARP_style_probe</span></code>, to find a sensible initialization for the probe. This particular initialization is based on the approach used in the SHARP package. Once all the needed information has been collected, we initialize the object.</p>
</section>
<section id="the-forward-model">
<h3>The Forward Model<a class="headerlink" href="#the-forward-model" title="Link to this heading"></a></h3>
<p>First, we have to implement the interaction model. This function should take the inputs defining the specific diffraction pattern or collection of patterns, and return an exit wave or set of exit waves that would be expected from that set of inputs. This models the interaction of the probe with the sample</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">interaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">translations</span><span class="p">):</span>
    <span class="n">pix_trans</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">interactions</span><span class="o">.</span><span class="n">translations_to_pixel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="p">,</span>
                                                         <span class="n">translations</span><span class="p">)</span>
    <span class="n">pix_trans</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_translation</span>
    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">interactions</span><span class="o">.</span><span class="n">ptycho_2D_round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span>
                                              <span class="n">pix_trans</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we take input in the form of an index and a translation. Note that this has to match the format that is output by the associated datasets that we will use for reconstruction.</p>
<p>We start by mapping the translation, given in real space, into pixel coordinates. Then, we use an “off-the-shelf” interaction model - <code class="code docutils literal notranslate"><span class="pre">ptycho_2d_round</span></code>, which models a standard 2D ptychography interaction, but rounds the translations to the nearest whole pixel (does not attempt subpixel translations).</p>
<p>The next three definitions amount to just choosing an off-the-shelf function to simulate each step in the chain.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">forward_propagator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavefields</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">propagators</span><span class="o">.</span><span class="n">far_field</span><span class="p">(</span><span class="n">wavefields</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavefields</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">intensity</span><span class="p">(</span><span class="n">wavefields</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">real_data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tools</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">amplitude_mse</span><span class="p">(</span><span class="n">real_data</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">)</span>
</pre></div>
</div>
<p>The forward propagator maps the exit wave to the wave at the surface of the detector, here using a far-field propagator. The measurement maps that exit wave to a measured pixel value, and the loss defines a loss function to attempt to minimize. The loss function we’ve chosen - the amplitude mean squared error - is the most broadly applicable one.</p>
</section>
<section id="device-management">
<h3>Device Management<a class="headerlink" href="#device-management" title="Link to this heading"></a></h3>
<p>Next we need to implement a <code class="code docutils literal notranslate"><span class="pre">to()</span></code> function, just like we did in the dataset, to allow the entire model to be moved between the GPU and CPU.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">SimplePtycho</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">min_translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_translation</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>We start by calling the same function for the superclass, which will take care of moving every parameter attached to the model. Then we manually take care of moving over the other variables which, while not being updated in the gradient descent, still need to be moved over to the new device!</p>
</section>
<section id="plotting">
<h3>Plotting<a class="headerlink" href="#plotting" title="Link to this heading"></a></h3>
<p>The base CDIModel class has a function, <code class="code docutils literal notranslate"><span class="pre">model.inspect()</span></code>, which looks for a class variable called <code class="code docutils literal notranslate"><span class="pre">plot_list</span></code> and plots everything contained within. The plot list should be formatted as a list of tuples, with each tuple containing:</p>
<ul class="simple">
<li><p>The title of the plot</p></li>
<li><p>A function that takes in the model and generates the relevant plot</p></li>
<li><p>Optional, a function that takes in the model and returns whether or not the plot should be generated</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;Probe Amplitude&#39;</span><span class="p">,</span>
     <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">:</span> <span class="n">tools</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_amplitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="p">)),</span>
    <span class="p">(</span><span class="s1">&#39;Probe Phase&#39;</span><span class="p">,</span>
     <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">:</span> <span class="n">tools</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="p">)),</span>
    <span class="p">(</span><span class="s1">&#39;Object Amplitude&#39;</span><span class="p">,</span>
     <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">:</span> <span class="n">tools</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_amplitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="p">)),</span>
    <span class="p">(</span><span class="s1">&#39;Object Phase&#39;</span><span class="p">,</span>
     <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">:</span> <span class="n">tools</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_basis</span><span class="p">))</span>
<span class="p">]</span>
</pre></div>
</div>
<p>In this case, we’ve made use of the convenience plotting functions defined in <code class="code docutils literal notranslate"><span class="pre">tools.plotting</span></code>.</p>
</section>
<section id="saving">
<h3>Saving<a class="headerlink" href="#saving" title="Link to this heading"></a></h3>
<p>At the moment, there is no consistent way to save out the results across the board. However, a function <code class="code docutils literal notranslate"><span class="pre">save_results()</span></code> should be defined, which should save out the results of the reconstruction into some reasonably formatted python object. Here we return a dictionary with the probe and object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">probe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">probe</span> <span class="o">=</span> <span class="n">probe</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_norm</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;probe&#39;</span><span class="p">:</span><span class="n">probe</span><span class="p">,</span><span class="s1">&#39;obj&#39;</span><span class="p">:</span><span class="n">obj</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="testing">
<h3>Testing<a class="headerlink" href="#testing" title="Link to this heading"></a></h3>
<p>We can test this model with a simple script, shown below. By filling in the backend here, we’ve been able to create a ptychography model that can be accessed and used in reconstructions via the same interface as the models we discussed in the examples section.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">basic_ptycho_dataset</span> <span class="kn">import</span> <span class="n">BasicPtychoDataset</span>
<span class="kn">from</span> <span class="nn">h5py</span> <span class="kn">import</span> <span class="n">File</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;example_data/lab_ptycho_data.cxi&#39;</span>
<span class="k">with</span> <span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">BasicPtychoDataset</span><span class="o">.</span><span class="n">from_cxi</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


<span class="n">model</span> <span class="o">=</span> <span class="n">SimplePtycho</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">dataset</span><span class="o">.</span><span class="n">get_as</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">loss</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">Adam_optimize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">report</span><span class="p">())</span>

<span class="n">model</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Happy modeling!</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="general.html" class="btn btn-neutral float-right" title="General Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2024, Abraham Levitan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>